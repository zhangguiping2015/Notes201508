<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>数组去重的最优方式</title>
</head>
<body>
<script type="text/javascript">
    //排序的原理非常的简单,自己获取对照 免费课视频-->第一周-->19、数组应用之冒泡排序 按照分析思路自己去写一遍即可 -->冒泡排序是JS中非常重要的简单的编程算法，除了冒泡排序外，还有插入排序和快速排序，建议大家自己回去研究

    //数组去重就是把数组中的重复项删除掉
    //1)使用双重for循环:首先循环数组中的每一项，然后让每一项和其后面的所有项进行比较，遇到重复的，我们把其删除即可 -->[免费课视频-->第一周-->20]自己去研究

    //2)优化方案之：利用对象的原理实现
    //a、把数组中的每一项的值，当做一个新的对象的属性名和属性值保存起来；例如：var obj={};  {1:1,2:2,3:3...}
    //b、但是在每一次存储之前，我们判断对象中是否包含了这一项的值；例如：我接下来要存储的是数组中的3，首先判断3是否是对象中的属性名(按照预设步骤，如果对象中有3这个属性，那么它的属性名是3，属性值也是3--> obj[3]==3 如果条件成立，就代表属性名3已经存在)
    //c、不包含的话我们就存储，包含的话说明数组中这一项重复了，我们把其删除即可
    //    var ary = [1, 1, 2, 2, 3, 2, 3, 1, 2, 3, 2, 1, 2, 3, 4, 5, 2, 3, 1];
    //    var obj = {};
    //    for (var i = 0; i < ary.length; i++) {
    //        var cur = ary[i];
    //        if (obj[cur] == cur) {
    //            ary.splice(i, 1);
    //            //数组塌陷问题：使用splice删除当前项，当前项后面每一项的索引都会从新的计算(在原有的索引基础上向前提一位)，如果我们的循环继续执行,索引i的值会继续向后累加，这样就造成了，中间有一项会被忽略掉 ，例如：i=1的时候，我们删除了数组中的第二项，后面每一项的索引都会向前提升一位，i++后变为了2，下一次我们从索引2开始的话，发现之前的一个2被空开了
    //            i--;//解决数组塌陷问题
    //            continue;
    //        }
    //        obj[cur] = cur;
    //    }
    //    console.log(ary);

    //     i=0 第一次循环 obj={}  cur=1  -->obj={1:1}
    //     i=1 第二次循环 cur=1 删除 splice(1,1) 把数组中的第二项删除了
    //     i=2 第三次循环 cur=2 发现前面的那个2还没有处理过呢

    //ary.splice(i, 1);实现删除的话，后面所有项的索引都需要重新的计算，如果后面有一百万项，浏览器就会卡死-->如何解决?
    //我们这一次不是让后面所有的项都动，而是只让最后一项替换当前项(中间的就不需要动了)，最后一项就没有用了，我们在把租后一项删除掉
    var ary = [1, 100, 2, 2, 3, 2, 3, 1, 2, 3, 2, 1, 2, 3, 4, 5, 2, 3];
    var obj = {};
    for (var i = 0; i < ary.length; i++) {
        var item = ary[i];
        if (obj[item] == item) {
            ary[i] = ary[ary.length - 1];//把最后一项的值，赋值给我们的当前项，目前当前项就被最后一项覆盖掉了
            ary.length -= 1;//把最后一项删除
            i--;
            continue;
        }
        obj[item] = item;
    }
    obj = null;
    console.log(ary);

</script>
</body>
</html>